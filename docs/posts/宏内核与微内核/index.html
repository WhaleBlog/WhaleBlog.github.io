<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="完整内容请见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert
Monolithic Kernel 宏内核优势 monolithic 的意思是指操作系统内核是一个完成了各种事情的大的程序，我们熟知的 Linux 是由这种方式所构建。通常来说 monolithic kernel 集成了文件系统，内存分配，调度器，虚拟内存系统等一系列复杂的组件，以及许多强大的抽象。这样带来的好处是显而易见的：
这些高度抽象的接口通常是可移植的，可以在各种各样的存储设备上实现文件和目录，而不需要改变代码
可以向应用程序隐藏复杂性。Linux 提供了地址空间的抽象，而不是让程序直接访问 MMU。另外一个例子是，我们可以直接对 fd 调用 read/write，而不需要直接接触文件系统中各个层级
帮助管理共享资源，比如内存与磁盘
因为所有这些功能都在一个程序里面，所以组件之间可以访问彼此的数据结构，进而使得依赖多个组件的工具更容易实现。比如 exec 系统调用，它依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是在内核态我们可以没有隔离地访问 inode，proc，pgtbl 等结构体，所以 exec 的中实现是相对简单的
内核的所有代码都以完整的硬件权限（内核都在 Supervisor mode）在运行，这也简化了软件的实现
宏内核劣势 但是其缺点也很明显，这也是为什么其他内核架构，比如微内核，出现的原因，monolithic kernel 并不适用于所有的场景：
它们大且复杂。到目前为止，Linux 的代码量来到了千万行。一个组件可以很方便地与另一个组件交互，这确实使得编程更容易了，但同样意味着内部代码有大量的交互和依赖，以至于看明白代码都有挑战。而且大型的程序与复杂的结构也同样伴随着大量的 Bug 与安全漏洞，如果使用宏内核，这些几乎不可避免
另一个人们不喜欢 monolithic kernel 的原因是，随着时间的推移，它们倾向于发展成拥有所有的功能。Linux 应用在各种场合中，从移动电话到桌面工作站，从笔记本电脑到平板电脑，从服务器到路由器。Linux可以支持这么多设备是极好的，这也使得 Linux 非常的通用。这很好，但是另一方面，通用就意味着慢。对于各种不同的场景都能支持，或许就不能对某些特定场景进行优化。况且很多时候我们根本用不着这么多功能。另外，这也使得完成一些简单的工作需要做很多额外的事情：比如当我们使用 pipe 时，我们需要 buffering，locking，sleep/wakeup，还有 context switching&amp;hellip;&amp;hellip; 但是对于从一个进程移动一个字节到另一个进程来说，这里有大量的内容或许并不是必须的
宏内核还可能因为太大反而削弱了抽象能力。你可以 wait 你自己 fork 的子进程，但不可以等待其他的；你可以 mmap 自己的地址空间，但是为了隔离性不能修改其他的；你可以在磁盘上建一个 B 树，但是读取磁盘时，文件系统不知道这是一个 B 树，这反而不利于效率
还有就是可扩展性，你只能使用内核提供的能力
Micro Kernel 微内核是指一种通用的方法或者概念，并不特指任何特定的产品
微内核的核心就是实现了 IPC（Inter-Process Communication）以及线程和任务的 tiny kernel。所以微内核只提供了进程抽象和通过IPC进程间通信的方式，除此之外别无他物。任何你想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现" />
<meta name="keywords" content=", mit-6.s081" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://whaleblog.github.io/posts/%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8/" />


    <title>
        
            宏内核与微内核 :: WhaleFall&#39;s Blog 
        
    </title>





  <link rel="stylesheet" href="/main.min.ab5336003ba331300318b49292c672210905baf1ef5410a739f647e70c8808fa.css" integrity="sha256-q1M2ADujMTADGLSSksZyIQkFuvHvVBCnOfZH5wyICPo=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="宏内核与微内核">
<meta itemprop="description" content="完整内容请见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert
Monolithic Kernel 宏内核优势 monolithic 的意思是指操作系统内核是一个完成了各种事情的大的程序，我们熟知的 Linux 是由这种方式所构建。通常来说 monolithic kernel 集成了文件系统，内存分配，调度器，虚拟内存系统等一系列复杂的组件，以及许多强大的抽象。这样带来的好处是显而易见的：
这些高度抽象的接口通常是可移植的，可以在各种各样的存储设备上实现文件和目录，而不需要改变代码
可以向应用程序隐藏复杂性。Linux 提供了地址空间的抽象，而不是让程序直接访问 MMU。另外一个例子是，我们可以直接对 fd 调用 read/write，而不需要直接接触文件系统中各个层级
帮助管理共享资源，比如内存与磁盘
因为所有这些功能都在一个程序里面，所以组件之间可以访问彼此的数据结构，进而使得依赖多个组件的工具更容易实现。比如 exec 系统调用，它依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是在内核态我们可以没有隔离地访问 inode，proc，pgtbl 等结构体，所以 exec 的中实现是相对简单的
内核的所有代码都以完整的硬件权限（内核都在 Supervisor mode）在运行，这也简化了软件的实现
宏内核劣势 但是其缺点也很明显，这也是为什么其他内核架构，比如微内核，出现的原因，monolithic kernel 并不适用于所有的场景：
它们大且复杂。到目前为止，Linux 的代码量来到了千万行。一个组件可以很方便地与另一个组件交互，这确实使得编程更容易了，但同样意味着内部代码有大量的交互和依赖，以至于看明白代码都有挑战。而且大型的程序与复杂的结构也同样伴随着大量的 Bug 与安全漏洞，如果使用宏内核，这些几乎不可避免
另一个人们不喜欢 monolithic kernel 的原因是，随着时间的推移，它们倾向于发展成拥有所有的功能。Linux 应用在各种场合中，从移动电话到桌面工作站，从笔记本电脑到平板电脑，从服务器到路由器。Linux可以支持这么多设备是极好的，这也使得 Linux 非常的通用。这很好，但是另一方面，通用就意味着慢。对于各种不同的场景都能支持，或许就不能对某些特定场景进行优化。况且很多时候我们根本用不着这么多功能。另外，这也使得完成一些简单的工作需要做很多额外的事情：比如当我们使用 pipe 时，我们需要 buffering，locking，sleep/wakeup，还有 context switching&hellip;&hellip; 但是对于从一个进程移动一个字节到另一个进程来说，这里有大量的内容或许并不是必须的
宏内核还可能因为太大反而削弱了抽象能力。你可以 wait 你自己 fork 的子进程，但不可以等待其他的；你可以 mmap 自己的地址空间，但是为了隔离性不能修改其他的；你可以在磁盘上建一个 B 树，但是读取磁盘时，文件系统不知道这是一个 B 树，这反而不利于效率
还有就是可扩展性，你只能使用内核提供的能力
Micro Kernel 微内核是指一种通用的方法或者概念，并不特指任何特定的产品
微内核的核心就是实现了 IPC（Inter-Process Communication）以及线程和任务的 tiny kernel。所以微内核只提供了进程抽象和通过IPC进程间通信的方式，除此之外别无他物。任何你想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现"><meta itemprop="datePublished" content="2024-08-31T11:45:36+00:00" />
<meta itemprop="dateModified" content="2024-08-31T11:45:36+00:00" />
<meta itemprop="wordCount" content="219"><meta itemprop="image" content="https://whaleblog.github.io/" />
<meta itemprop="keywords" content="mit-6.s081," />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://whaleblog.github.io/" /><meta name="twitter:title" content="宏内核与微内核"/>
<meta name="twitter:description" content="完整内容请见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert
Monolithic Kernel 宏内核优势 monolithic 的意思是指操作系统内核是一个完成了各种事情的大的程序，我们熟知的 Linux 是由这种方式所构建。通常来说 monolithic kernel 集成了文件系统，内存分配，调度器，虚拟内存系统等一系列复杂的组件，以及许多强大的抽象。这样带来的好处是显而易见的：
这些高度抽象的接口通常是可移植的，可以在各种各样的存储设备上实现文件和目录，而不需要改变代码
可以向应用程序隐藏复杂性。Linux 提供了地址空间的抽象，而不是让程序直接访问 MMU。另外一个例子是，我们可以直接对 fd 调用 read/write，而不需要直接接触文件系统中各个层级
帮助管理共享资源，比如内存与磁盘
因为所有这些功能都在一个程序里面，所以组件之间可以访问彼此的数据结构，进而使得依赖多个组件的工具更容易实现。比如 exec 系统调用，它依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是在内核态我们可以没有隔离地访问 inode，proc，pgtbl 等结构体，所以 exec 的中实现是相对简单的
内核的所有代码都以完整的硬件权限（内核都在 Supervisor mode）在运行，这也简化了软件的实现
宏内核劣势 但是其缺点也很明显，这也是为什么其他内核架构，比如微内核，出现的原因，monolithic kernel 并不适用于所有的场景：
它们大且复杂。到目前为止，Linux 的代码量来到了千万行。一个组件可以很方便地与另一个组件交互，这确实使得编程更容易了，但同样意味着内部代码有大量的交互和依赖，以至于看明白代码都有挑战。而且大型的程序与复杂的结构也同样伴随着大量的 Bug 与安全漏洞，如果使用宏内核，这些几乎不可避免
另一个人们不喜欢 monolithic kernel 的原因是，随着时间的推移，它们倾向于发展成拥有所有的功能。Linux 应用在各种场合中，从移动电话到桌面工作站，从笔记本电脑到平板电脑，从服务器到路由器。Linux可以支持这么多设备是极好的，这也使得 Linux 非常的通用。这很好，但是另一方面，通用就意味着慢。对于各种不同的场景都能支持，或许就不能对某些特定场景进行优化。况且很多时候我们根本用不着这么多功能。另外，这也使得完成一些简单的工作需要做很多额外的事情：比如当我们使用 pipe 时，我们需要 buffering，locking，sleep/wakeup，还有 context switching&hellip;&hellip; 但是对于从一个进程移动一个字节到另一个进程来说，这里有大量的内容或许并不是必须的
宏内核还可能因为太大反而削弱了抽象能力。你可以 wait 你自己 fork 的子进程，但不可以等待其他的；你可以 mmap 自己的地址空间，但是为了隔离性不能修改其他的；你可以在磁盘上建一个 B 树，但是读取磁盘时，文件系统不知道这是一个 B 树，这反而不利于效率
还有就是可扩展性，你只能使用内核提供的能力
Micro Kernel 微内核是指一种通用的方法或者概念，并不特指任何特定的产品
微内核的核心就是实现了 IPC（Inter-Process Communication）以及线程和任务的 tiny kernel。所以微内核只提供了进程抽象和通过IPC进程间通信的方式，除此之外别无他物。任何你想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现"/>



    <meta property="og:title" content="宏内核与微内核" />
<meta property="og:description" content="完整内容请见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert
Monolithic Kernel 宏内核优势 monolithic 的意思是指操作系统内核是一个完成了各种事情的大的程序，我们熟知的 Linux 是由这种方式所构建。通常来说 monolithic kernel 集成了文件系统，内存分配，调度器，虚拟内存系统等一系列复杂的组件，以及许多强大的抽象。这样带来的好处是显而易见的：
这些高度抽象的接口通常是可移植的，可以在各种各样的存储设备上实现文件和目录，而不需要改变代码
可以向应用程序隐藏复杂性。Linux 提供了地址空间的抽象，而不是让程序直接访问 MMU。另外一个例子是，我们可以直接对 fd 调用 read/write，而不需要直接接触文件系统中各个层级
帮助管理共享资源，比如内存与磁盘
因为所有这些功能都在一个程序里面，所以组件之间可以访问彼此的数据结构，进而使得依赖多个组件的工具更容易实现。比如 exec 系统调用，它依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是在内核态我们可以没有隔离地访问 inode，proc，pgtbl 等结构体，所以 exec 的中实现是相对简单的
内核的所有代码都以完整的硬件权限（内核都在 Supervisor mode）在运行，这也简化了软件的实现
宏内核劣势 但是其缺点也很明显，这也是为什么其他内核架构，比如微内核，出现的原因，monolithic kernel 并不适用于所有的场景：
它们大且复杂。到目前为止，Linux 的代码量来到了千万行。一个组件可以很方便地与另一个组件交互，这确实使得编程更容易了，但同样意味着内部代码有大量的交互和依赖，以至于看明白代码都有挑战。而且大型的程序与复杂的结构也同样伴随着大量的 Bug 与安全漏洞，如果使用宏内核，这些几乎不可避免
另一个人们不喜欢 monolithic kernel 的原因是，随着时间的推移，它们倾向于发展成拥有所有的功能。Linux 应用在各种场合中，从移动电话到桌面工作站，从笔记本电脑到平板电脑，从服务器到路由器。Linux可以支持这么多设备是极好的，这也使得 Linux 非常的通用。这很好，但是另一方面，通用就意味着慢。对于各种不同的场景都能支持，或许就不能对某些特定场景进行优化。况且很多时候我们根本用不着这么多功能。另外，这也使得完成一些简单的工作需要做很多额外的事情：比如当我们使用 pipe 时，我们需要 buffering，locking，sleep/wakeup，还有 context switching&hellip;&hellip; 但是对于从一个进程移动一个字节到另一个进程来说，这里有大量的内容或许并不是必须的
宏内核还可能因为太大反而削弱了抽象能力。你可以 wait 你自己 fork 的子进程，但不可以等待其他的；你可以 mmap 自己的地址空间，但是为了隔离性不能修改其他的；你可以在磁盘上建一个 B 树，但是读取磁盘时，文件系统不知道这是一个 B 树，这反而不利于效率
还有就是可扩展性，你只能使用内核提供的能力
Micro Kernel 微内核是指一种通用的方法或者概念，并不特指任何特定的产品
微内核的核心就是实现了 IPC（Inter-Process Communication）以及线程和任务的 tiny kernel。所以微内核只提供了进程抽象和通过IPC进程间通信的方式，除此之外别无他物。任何你想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whaleblog.github.io/posts/%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8/" /><meta property="og:image" content="https://whaleblog.github.io/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-31T11:45:36+00:00" />
<meta property="article:modified_time" content="2024-08-31T11:45:36+00:00" />





    <meta property="article:section" content="notes" />

    <meta property="article:section" content="courses" />



    <meta property="article:published_time" content="2024-08-31 11:45:36 &#43;0000 UTC" />












    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                WhaleFall</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/tags">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        2分钟阅读

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://whaleblog.github.io/posts/%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8/">宏内核与微内核</a>
      </h1>

      

      

      

      <div class="post-content">
        <p>完整内容请见：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec18-os-organization-robert</a></p>
<h2 id="monolithic-kernel">Monolithic Kernel</h2>
<h3 id="宏内核优势">宏内核优势</h3>
<p>monolithic 的意思是指操作系统内核是一个完成了各种事情的大的程序，我们熟知的 Linux 是由这种方式所构建。通常来说 monolithic kernel 集成了文件系统，内存分配，调度器，虚拟内存系统等一系列复杂的组件，以及许多强大的抽象。这样带来的好处是显而易见的：</p>
<ol>
<li>
<p>这些高度抽象的接口通常是可移植的，可以在各种各样的存储设备上实现文件和目录，而不需要改变代码</p>
</li>
<li>
<p>可以向应用程序隐藏复杂性。Linux 提供了地址空间的抽象，而不是让程序直接访问 MMU。另外一个例子是，我们可以直接对 fd 调用 read/write，而不需要直接接触文件系统中各个层级</p>
</li>
<li>
<p>帮助管理共享资源，比如内存与磁盘</p>
</li>
<li>
<p>因为所有这些功能都在一个程序里面，所以组件之间可以访问彼此的数据结构，进而使得依赖多个组件的工具更容易实现。比如 exec 系统调用，它依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是在内核态我们可以没有隔离地访问 inode，proc，pgtbl 等结构体，所以 exec 的中实现是相对简单的</p>
</li>
<li>
<p>内核的所有代码都以完整的硬件权限（内核都在 Supervisor mode）在运行，这也简化了软件的实现</p>
</li>
</ol>
<h3 id="宏内核劣势">宏内核劣势</h3>
<p>但是其缺点也很明显，这也是为什么其他内核架构，比如微内核，出现的原因，monolithic kernel 并不适用于所有的场景：</p>
<ol>
<li>
<p>它们大且复杂。到目前为止，Linux 的代码量来到了千万行。一个组件可以很方便地与另一个组件交互，这确实使得编程更容易了，但同样意味着内部代码有大量的交互和依赖，以至于看明白代码都有挑战。而且大型的程序与复杂的结构也同样伴随着大量的 Bug 与安全漏洞，如果使用宏内核，这些几乎不可避免</p>
</li>
<li>
<p>另一个人们不喜欢 monolithic kernel 的原因是，随着时间的推移，它们倾向于发展成拥有所有的功能。Linux 应用在各种场合中，从移动电话到桌面工作站，从笔记本电脑到平板电脑，从服务器到路由器。Linux可以支持这么多设备是极好的，这也使得 Linux 非常的通用。这很好，但是另一方面，通用就意味着慢。对于各种不同的场景都能支持，或许就不能对某些特定场景进行优化。况且很多时候我们根本用不着这么多功能。另外，这也使得完成一些简单的工作需要做很多额外的事情：比如当我们使用 pipe 时，我们需要 buffering，locking，sleep/wakeup，还有 context switching&hellip;&hellip; 但是对于从一个进程移动一个字节到另一个进程来说，这里有大量的内容或许并不是必须的</p>
</li>
<li>
<p>宏内核还可能因为太大反而削弱了抽象能力。你可以 wait 你自己 fork 的子进程，但不可以等待其他的；你可以 mmap 自己的地址空间，但是为了隔离性不能修改其他的；你可以在磁盘上建一个 B 树，但是读取磁盘时，文件系统不知道这是一个 B 树，这反而不利于效率</p>
</li>
<li>
<p>还有就是可扩展性，你只能使用内核提供的能力</p>
</li>
</ol>
<h2 id="micro-kernel">Micro Kernel</h2>
<p>微内核是指一种通用的方法或者概念，并不特指任何特定的产品</p>
<p>微内核的核心就是实现了 IPC（Inter-Process Communication）以及线程和任务的 tiny kernel。所以微内核只提供了进程抽象和通过IPC进程间通信的方式，除此之外别无他物。任何你想要做的事情，例如文件系统，你都会通过一个用户空间进程来实现，完全不会在内核中实现</p>
<p>在这种实现中，假如一个文本编辑器需要读取一个文件，它通过 IPC 会发送一条消息到文件系统进程。文件系统进程需要与磁盘交互，所以它会发送另一个 IPC 到磁盘驱动程序。之后磁盘驱动会返回一个磁盘块给文件系统。之后文件系统再将VI请求的数据通过 IPC 返回给文本编辑器</p>
<p>可以看到，在内核中唯一需要做的是支持进程/任务/线程，以及支持 IPC 来作为消息的传递途径，除此之外，内核不用做任何事情。内核中没有任何文件系统，没有任何设备驱动，没有网络协议栈，所有这些东西以普通用户进程在运行</p>
<h3 id="研究微内核的动机">研究微内核的动机</h3>
<p>其实这里面还有审美因素：有人觉得像 Linux 内核这样大的复杂的程序并不十分优雅。我们可以构建一些小得多且专注得多的设计，而不是这样一个巨大的拥有各种随机特性的集合体</p>
<p>但其实微内核有更多具体的优势：</p>
<ol>
<li>
<p>更小的内核或许会更加的安全</p>
</li>
<li>
<p>在特殊场景下，你需要证明一个操作系统是正确且安全的。而一个几百万行的内核不太可能保证。内核通常都很小，这是它能够被证明是安全的一个关键因素</p>
</li>
<li>
<p>少量代码的程序比巨大的程序更容易被优化</p>
</li>
<li>
<p>小内核可能会运行的更快，你不用为很多用不上的功能付出代价</p>
</li>
<li>
<p>小内核在设计上或许有更少的限制，应用程序的编写可以更加灵活</p>
</li>
</ol>
<p>除了由小带来的有点，它的设计也使得其有独特的特性：</p>
<ol>
<li>
<p>有很多我们习惯了位于内核的功能和函数，现在都运行在用户空间的不同部分，可以使得代码更模块化</p>
</li>
<li>
<p>运行在用户空间的代码更容易被修改，所以更容易被定制化</p>
</li>
<li>
<p>此外，这种设计还可以使 OS 更加健壮。如果内核出错，通常需要 panic 并重启。但是故障部分被转移到了用户空间，我们可以只是重新启动这一个服务，而不影响其他功能。这对于驱动来说尤其明显，内核中大部分 Bug 都在硬件驱动中，如果我们能将设备驱动从内核中移出的话，那么内核中可能会有少的多的 Bug 和 Crash</p>
</li>
<li>
<p>可以在微内核上模拟或者运行多个操作系统。我们可以把一个完整的 Linux 内核当作一个·任务运行在微内核上</p>
</li>
</ol>
<h3 id="微内核的挑战">微内核的挑战</h3>
<ol>
<li>
<p>第一个挑战是，我们希望微内核的系统调用接口尽可能的简单，但是什么才是有用的系统调用的最小集？我们需要考虑如何设计这些底层的系统调用，在简单的同时，需要能够足够强大以支持人们需要做的各种事情</p>
</li>
<li>
<p>我们仍然需要开发一些用户空间服务来实现操作系统的其他部分。比如我们的系统调用需要支持 exec，但是内核没有文件的抽象</p>
</li>
<li>
<p>微内核的设计需要进程间通过 IPC 有大量的通信，这要求 IPC 非常快，否则很影响性能</p>
</li>
</ol>
<h2 id="l4">L4</h2>
<p>L4 是最早的一批可工作的微内核</p>
<h3 id="l4-简介">L4 简介</h3>
<p>L4 是微内核，它只有7个系统调用</p>
<p>L4 并不大，论文发表的时候，它只有 13000 行代码</p>
<p>Task，线程，地址空间，IPC 是 L4 唯四有的抽象</p>
<p>L4里面不包含其他的功能，没有文件系统，没有fork/exec系统调用，除了这里非常简单的IPC之外，没有其他例如pipe的通信机制，没有设备驱动，没有网络的支持等等。任何其他你想要的功能，你需要以用户空间进程的方式提供</p>
<p>L4能提供的一件事情是完成线程间切换。L4会完成线程调度和context switch，来让多个线程共用一个CPU。它的实现方式其实和我们熟知的线程切换方式非常类似</p>
<h2 id="improving-ipc">Improving IPC</h2>
<p>如果是像 pipe 的实现，P1 与 P2 通信完成一次消息的发送与接收。P1 会调用 send，陷入内核，向 buffer 中写消息。在 send 返回后，又调用 recv 来获取回复，期间会 sleep 等待，可能会在计时器到来时 context switching。过一会 P2 有空，调用 recv 接受消息，处理完后调用 send 追加到 buffer。等到调度器使 P1 回复运行，看到 buffer 中有消息，recv 才返回&hellip;&hellip;</p>
<p>在这个设计中，为了让消息能够发送和回复，期间有多次的用户态与内核态切换，4 次系统调用，若是单核，还得至少有一次 context switching 在 P1 与 P2 中切换。每一次用户空间和内核空间之间的切换和 context switching 都很费时，因为每次切换，都需要切换 Page Table，进而清空 TLB。而且不仅如此还牵涉到消息的拷贝、缓存的分配等等。可见这种异步的设计是非常慢的</p>
<p>但是我们只是期望发送一个消息然后得到一个回复，我们完全可以有更简单的设计</p>
<h3 id="synchronized">Synchronized</h3>
<p>比如我们的 send 和 recv 是一体的：send 会等待消息被接收，并且 recv 会等待回复消息被发送。如果我是进程 P1，我想要发送消息，我会调用 send，send 不会写完 buffer 就走人，而是等待 P2 的 recv。当 P2 调用 recv，二者都在内核中，此时内核可以直接将消息从用户空间 P1 拷贝到用户空间 P2，而不用先拷贝到内核中，再从内核中拷出来</p>
<h3 id="avoid-copying">Avoid Copying</h3>
<p>如果消息超级小，比如说只有几十个字节，它可以在寄存器中传递，而不需要拷贝。如果P1要发送的消息很短，它可以将消息存放到特定的寄存器中。当内核返回到P2进程的用户空间时，会恢复保存了的寄存器，这意味着当内核从recv系统调用返回时，特定寄存器的内容就是消息的内容，因此完全不需要从内存拷贝到内存</p>
<p>对于非常长的消息，可以在一个 IPC 消息中携带一个 Page 映射。你可以发送一个物理内存 Page，这个 Page 会被再次映射到目标 Task 地址空间，这里也没有拷贝。这里提供的是共享 Page 的权限</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://whaleblog.github.io/tags/mit-6.s081/">mit-6.s081</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://whaleblog.github.io/categories/notes/">notes</a></span>
        <span class="tag"><a href="https://whaleblog.github.io/categories/courses/">courses</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        219字
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2024-08-31 19:45
        

         
          
        
      </p>
    </div>
      <hr />
      <div class="sharing-buttons">
        

  
    
    
  




  
      
        
    
  




  
    
      
    
  




  
    
    
  




  
    
    
  




  
    
    
  




  
    
    
  




  
    
    
  




  
    
    
  




  
			
    
  




  
      
    
  


<style>
.social-icons {
  display: flex;
  align-items: center;
  gap: 20px;  
  margin-top: 15px;
}
.social-icons a svg {
  width: 20px;  
  height: 20px;
}
</style>

<div class="social-icons">
  
  <a href="mailto:166845494@qq.com" target="_self" rel="noopener" aria-label="Email me" title="Email me">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
      <polyline points="22,6 12,13 2,6"></polyline>
    </svg>
  </a>

  
  <a href="https://github.com/WhaleFall-UESTC" target="_blank" rel="noopener" aria-label="Follow on GitHub" title="Follow on GitHub">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke-width="2">
      <path d="M12 0C5.373 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.298 24 12c0-6.627-5.373-12-12-12z"/>
    </svg>
  </a>
</div>

      </div>

    
    <div class="pagination">
        
        <div class="pagination__title">
            <span class="pagination__title-h">浏览其他文章</span>
            <hr />
        </div>
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://whaleblog.github.io/posts/meltdown/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Meltdown</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://whaleblog.github.io/posts/xv6&#43;%E5%AE%9E%E9%AA%8C%E6%97%A5%E5%BF%97&#43;-&#43;sleep&#43;&#43;wakeup/">
                    <span class="button__text">xv6 实验日志 - Sleep &amp; Wakeup</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.ac2a4bcaed631ec2dc154407be7f09fc28da37de71fae6dee6711b2a3d1622770f87d3cda22c460e9a68ff619bdb1dd75cb7a5d33f159a54e419736cc4541087.js" integrity="sha512-rCpLyu1jHsLcFUQHvn8J/CjaN95x&#43;ube5nEbKj0WIncPh9PNoixGDppo/2Gb2x3XXLel0z8VmlTkGXNsxFQQhw=="></script>




    </body>
</html>
